<PROGRAM> ::= <DECLS>

/* declarations */
<DECLS> ::= <DECL> | <DECLS> <DECL>
<DECL> ::= <FN_DECL> | <VAR_DECL_STMT> ";" | VAR_DECL_INIT_STMT ";"

/* statement block */
<STMT_BLOCK> ::= "{" "}" | "{" <STMTS> "}"

/* statements */
<STMTS> ::= <STMT> | <STMTS> <STMT> 

/* statement */
<STMT> ::= <STATEMENT_W_DELIM> ";" | <STATEMENT_WO_DELIM> 

/* statement types by delimiter */
<STATEMENT_W_DELIM> ::= <IN_IO_STMT> | <OUT_IO_STMT> | <VAR_DECL_STMT> | <VAR_DECL_INIT_STMT> | <VAR_ASSIGN_STMT> | <EXPR_STMT> | <BREAK_STMT> | <CONTINUE_STMT> | <RETURN_STMT>
<STATEMENT_WO_DELIM> ::= <IF_STMT> | <WHILE_STMT> | <FOR_STMT>

/* statement parts */
<IN_IO_STMT> ::= "in" "(" <IN_ARG_SEQ> ")"
<OUT_IO_STMT> ::= "disp" "(" <EXPR_SEQ> ")" 
<VAR_DECL_STMT> ::= <VAR_DECL> | <LIST_DECL> | <STRUCT_DECL> 
<VAR_DECL_INIT_STMT> ::= <VAR_DECL_INIT> | <LIST_DECL_INIT>
<VAR_ASSIGN_STMT> ::= <VAR_ASSIGN> | <STRUCT_MEMBER_ASSIGN> | <LIST_ELEM_ASSIGN> | <ASSIGN_PTR> | <ASSIGN_PTR_VALUE>
<EXPR_STMT> ::= <EXPR> 
<IF_STMT> ::= <IF_IF> <IF_ELIFS> <IF_ELSE> | <IF_IF> <IF_ELSE> | <IF_IF> <IF_ELIFS> 
<WHILE_STMT> ::= "while" "(" <EXPR> ")" <STMT_BLOCK>
<FOR_STMT> ::= "for" "(" <FOR_INIT> ";" <FOR_CONDITION> ";" <FOR_INCREMENT> ")" <STMT_BLOCK>
<BREAK_STMT> ::= "break" 
<CONTINUE_STMT> ::= "continue" 
<RETURN_STMT> ::= "return" | "return" <EXPR_or_null> 

/* in-statement parts */
<IN_ARG_SEQ> ::= <EXPR_SEQ> <IN_VAR_SEQ>
<IN_VAR_SEQ> ::= "&" <VAR> | <IN_VAR_SEQ> "," "&" <VAR>

/* if-statement parts */
<IF_IF> ::= "if" "("<EXPR>")" <STMT_BLOCK>
<IF_ELIFS> ::= <IF_ELIF> | <IF_ELIFS> <IF_ELIF> 
<IF_ELIF> ::= "elif" "(" <EXPR> ")" <STMT_BLOCK>
<IF_ELSE> ::= "else" <STMT_BLOCK> 

/* for-statement parts */
<FOR_INIT> ::= <VAR_DECL> | <VAR_DECL_INIT> | <VAR_ASSIGN> | <EXPR> | ""
<FOR_CONDITION> ::= <VAR_ASSIGN> | <EXPR> | ""
<FOR_INCREMENT> ::= <VAR_ASSIGN> | <EXPR> | ""


/* DECLARATIONS */

/* function declaration */
<FN_DECL> ::= "fx" <IDENT> <PARAMS> "==>" <RETURN_TYPE> <STMT_BLOCK>

/* struct declaration */
<STRUCT_DECL> ::= "struct" <IDENT> <VAR_DECL_STMT_BLOCk>
<VAR_DECL_STMT_BLOCk> ::= "{" <VAR_DECL_STMTS> "}"
<VAR_DECL_STMTS> ::= <VAR_DECL_STMT> | <VAR_DECL_STMTS> <VAR_DECL_STMT>
<VAR_DECL_STMT> ::= <LIST_DECL> ";" | <VAR_DECL> ";"

/* list declaration */
<LIST_DECL> ::= <EXPL_TYPE> <LIST_IDENT_W_SIZE>

/* variable declaration */
<EXPL_VAR_DECL> ::= <EXPL_TYPE> <IDENT>


/* DECLARATIONS WITH INITIALIZATION */

/* variable declaration with initialization */
<EXPL_VAR_DECL_INIT> ::= <EXPL_TYPE> <IDENT> "=" <EXPR_or_null> 

/* list declaration with initialization */
<LIST_DECL_INIT> ::= <LIST_IDENT_ANY> "=" <LIST_LIT> /* 


/* variable assignment (implicit and explicit) */
<VAR_ASSIGN> ::= <VAR> "=" <EXPR_or_null>

/* expressions */
<EXPR_OR_NULL_SEQ> ::= <EXPR_OR_NULL> | <EXPR_OR_NULL_SEQ> "," <EXPR_OR_NULL>
<EXPR_SEQ> ::= <EXPR> | <EXPR_SEQ> "," <EXPR>
<expr_or_null> ::= <EXPR> | <NULL>


/* expression */
<EXPR> ::= <OR>
<OR> ::= <AND> | <OR> <OP_OR> <AND>
<AND> ::= <CMP_EQ_NEQ> | <AND> <OP_AND> <CMP_EQ_NEQ>
<CMP_EQ_NEQ> ::= <CMP_GT_LT> | <CMP_EQ_NEQ> <OP_CMP_EQ_NEQ> <CMP_GT_LT>
<CMP_GT_LT> ::= <SUM_SUB> | <CMP_GT_LT> <OP_CMP_GT_LT> <SUM_SUB>
<SUM_SUB> ::= <MUL_DIV_MOD> | <SUM_SUB> <OP_SUM_SUB> <MUL_DIV_MOD>
<MUL_DIV_MOD> ::= <UNARY> | <MUL_DIV_MOD> <OP_MUL_DIV_MOD> <UNARY>
<UNARY> ::= <PRIMARY> | <OP_UNARY> <UNARY>
<PRIMARY> ::= <TYPE_MEMBER> | <VAR> | <FN_CALL> | "(" <EXPR> ")"

/* function call */
<FN_CALL> ::= <IDENT> <ARGS>

/* arguments */
<ARGS> ::= "(" ")" | "(" <ARGS_SEQ> ")"
<ARGS_SEQ> ::= <ARG> | <ARGS_SEQ> "," <ARG>
<ARG> ::= <expr_or_null>

/* parameters */
<PARAMS> ::= "(" ")" | "(" <PARAMS_SEQ> ")"
<PARAMS_SEQ> ::= <PARAM> | <PARAMS_SEQ> "," <PARAM>
<PARAM> ::= <EXPL_TYPE> <IDENT> | <LIST_TYPE>

/* variables */
<VAR_SEQ> ::= <VAR> | <VAR_SEQ> "," <VAR>
<VAR> ::= <IE_VAR> | <STRUCT_MEMBER>
<STRUCT_MEMBER> ::= <IE_VAR> "." <IDENT> | <STRUCT_MEMBER> "." <IDENT>
<IE_VAR> ::= <IMPL_VAR> | <EXPL_VAR>
<IMPL_VAR> ::= <EXPR> | <LIST_ACCESS_ELEM>
<EXPL_VAR> ::= <IDENT>


/* identifiers */
<IDENT> ::= <IDENT_HEAD_SYM> | <IDENT> <IDENT_TAIL_SYM>

/* TYPES */
<TYPE> ::= <EXPL_TYPE> | <LIST_TYPE>

/* return type */
<RETURN_TYPE> ::= <EXPL_TYPE> | VOID_TYPE

/* list type (implicit) */
<LIST_TYPE> ::= <EXPL_TYPE> <LIST_IDENT_W_SIZE> | <EXPL_TYPE> <LIST_IDENT_WO_SIZE>
<LIST_LIT> ::= "[" "]" | "[" <EXPR_SEQ> "]"
<LIST_ACCESS_ELEM> ::= <IDENT> "[" <expr> "]" | <EXPR> "[" <expr> "]"
<LIST_IDENT_ANY> ::= <LIST_IDENT_WO_SIZE> | <LIST_IDENT_W_SIZE>
<LIST_IDENT_W_SIZE> ::= <IDENT> "[" <expr> "]"
<LIST_IDENT_WO_SIZE> ::= <IDENT> "[" "]"

/* advanced types (explicit) */
<EXPL_TYPE> ::= <BASIC_N_STRUCT_TYPE> | <POINTER_TYPE>
<POINTER_TYPE> ::= <BASIC_N_STRUCT_N_VOID_TYPE> "*" | <POINTER_TYPE> "*"
<BASIC_N_STRUCT_N_VOID_TYPE> ::= <BASIC_N_STRUCT_TYPE> | <VOID_TYPE>
<VOID_TYPE> ::= "void"
<BASIC_N_STRUCT_TYPE> ::= <BASIC_TYPE> | <STRUCT_TYPE>
<STRUCT_TYPE> ::= "struct" <IDENT>;

/* basic types */
<BASIC_TYPE> ::= "int" | "float" | "bool" | "char" | "string" 
<STRING> ::= "\"" "\"" | "\"" <ANY> "\""
<CHAR> ::= "'" <ANY_SYM> "'" 
<BOOL> ::= "True" | "False"
<FLOAT> ::= <FLOAT_WO_E> | <FLOAT_WO_E> "e" <SIGNABLE_DIGITS> | <SIGNABLE_DIGITS> "e" <SIGNABLE_DIGITS>
<FLOAT_WO_E> ::= "." <DIGITS> | <SIGNABLE_DIGITS> "." |  <SIGNABLE_DIGITS> "." <DIGITS>
<INT> ::= <SIGNABLE_DIGITS>

/* unary operators */
<OP_UNARY> ::= "!" | "++" | "--" 

/* arithmetic operators */
<OP_MUL_DIV_MOD> ::= "*" | "/" | "%"

/* arithmetic operators */
<OP_SUM_SUB> ::= "+" | "-"

/* cmp operators */
<OP_CMP_GT_LT> ::= ">" | "<" | ">=" |"<="

/* cmp operators */
<OP_CMP_EQ_NEQ> ::= "==" | "!="

/* logical operators */
<OP_AND> ::= "AND"

/* logical operators */
<OP_OR> ::= "OR"

/* assign operators */
<OP_ASSIGN> ::= "=" | "+=" | "-=" | "*=" | "/=" | "%="

/* comments */
<COMMENT> ::= <COMMENT_LINE> | <COMMENT_BLOCK>
<COMMENT_LINE> ::= "#" <ANY_WO_ESCAPES> <NEWLINE> 
<COMMENT_BLOCK> ::= "###" <ANY_WO_ESCAPES> "###"

/* molecules */
<ANY> ::= <ANY_SYM> | <ANY> <ANY_SYM>
<ANY_WO_ESCAPES> ::= <ANY_SYM_WO_ESCAPES> | <ANY_WO_ESCAPES> <ANY_SYM_WO_ESCAPES>

<SIGNABLE_DIGITS> ::= <SIGN> <DIGITS> | <DIGITS>
<DIGITS> ::= <DIGIT> | <DIGITS> <DIGIT>

/* atoms */
<IDENT_TAIL_SYM> ::= <DIGIT> | <IDENT_HEAD_SYM>
<IDENT_HEAD_SYM> ::= <LETTER> | <UNDERSCORE>

<ANY_SYM> ::= <ANY_SYM_WO_ESCAPES> | <ESCAPED_SYM>
<ANY_SYM_WO_ESCAPES> ::= <DIGIT> | <LETTER> | <SPECIAL>

<ESCAPED_SYM> ::= "\\" <SYM_TO_BE_ESCAPED>
/* TODO add backslash to quote mark (removed temoporarily so that syntax highlighting is not broken) */
<SYM_TO_BE_ESCAPED> ::= "n" | "r" | "t" | "\\" | "\"

<NEWLINE> ::= "\\n" 
<SIGN> ::= "+" | "-"
<UNDERSCORE> ::= "_"

<SPECIAL> ::= "!" | "#" | "@" | "$" | "%" | "&" | "'" | "(" | ")" | "*" | "," | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?" | "@" | "[" | "]" | "^" | "`" | "{" | "}" | "|" | "~" | " " | "_" | "+" | "-" 
<LETTER> ::= <LCASE_LETTER> | <UCASE_LETTER>
<UCASE_LETTER> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
<LCASE_LETTER> ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
<DIGIT> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

----------------------------------
----------------------------------
----------------------------------
----------------------------------
----------------------------------
----------------------------------






listas[3] = 3;

<list_access> ::= <var> | <struct_var> |  <expr_resulting_in_pointer>  + [ <expr> ];

/* pointers */ 
int    *ip;    /* pointer to an integer */
double *dp;    /* pointer to a double */
float  *fp;    /* pointer to a float */
char   *ch     /* pointer to a character */
struct *strt;
int * arr[4];

int *a = NULL;
int *ptr = &num;
int *ptr = num;
char *ptr3 = &b - 11;

struct Test {
	...
};

struct *Test;
struct *Test = ...;

ip = &var;  /* store address of var in pointer variable*/
int *ptr = 123;

<POINTER_DECL> ::= <any_type_iskaitant_void> "****" ( <ident> | <list_ident> );
<POINTER_DECL_INIT> ::= <POINTER_DECL> "=" <EXPR> | NULL;



&var = 
**var = &var;
**(var) = &var;
**(ptr.name) = &var;
**(ptr.name+1) = &var;



<POINTER_DEREFERENCE_1> ::= "*" <++ or -- > <var>
<POINTER_DEREFERENCE_2> ::= <var> "[" <int>??? "]"
<POINTER_DEREFERENCE_3> ::= "*" "(" < ++ or -- > <var> <sign> <int>??? ")"

<REFERENCE_VARIABLE> ::= "&" <VAR>





printf("Address of var variable: %x\n", &var  );
/* address stored in pointer variable */
printf("Address stored in ip variable: %x\n", ip );
/* access the value using the pointer */
printf("Value of *ip variable: %d\n", *ip );


if(ptr)     /* succeeds if p is not null */
if(!ptr)    /* succeeds if p is null */

1	Pointer arithmetic
There are four arithmetic operators that can be used in pointers: ++, --, +, -

2	Array of pointers
You can define arrays to hold a number of pointers.

3	Pointer to pointer
C allows you to have pointer on a pointer and so on.

4	Passing pointers to functions in C
Passing an argument by reference or by address enable the passed argument to be changed in the calling function by the called function.

5	Return pointer from functions in C
C allows a function to return a pointer to the local variable, static variable, and dynamically allocated memory as well.


assert(*p == 'a');  // The first character at address p will be 'a'
assert(p[1] == 'b'); // p[1] actually dereferences a pointer created by adding
                     // p and 1 times the size of the things to which p points:
                     // In this case they're char which are 1 byte in C...
assert(*(p + 1) == 'b');  // Another notation for p[1]
++p;  // Increment p so it's now 0x1001
assert(*p == 'b');  // p == 0x1001 which is where the 'b' is...

int x = 2;
int* p_x = &x;  // Put the address of the x variable into the pointer p_x
*p_x = 4;       // Change the memory at the address in p_x to be 4
assert(x == 4); // Check x is now 4

typedef struct X { int i_; double d_; } X;
X x;
X* p = &x;
p->d_ = 3.14159;  // Dereference and access data member x.d_
(*p).d_ *= -1;    // Another equivalent notation for accessing x.d_

<var>.<attr>
(<var>).<attr>
(*<var>).<attr>
(list[2].attr)

(*p).d_ = ...

*p.d_ = ...

/*Multi-byte data types*/
double sizes[] = { 10.3, 13.4, 11.2, 19.4 };
double* p = sizes;
assert(p[0] == 10.3);  // Knows to look at all the bytes in the first double value
assert(p[1] == 13.4);  // Actually looks at bytes from address p + 1 * sizeof(double)
                       // (sizeof(double) is almost always eight bytes)
assert(++p);           // Advance p by sizeof(double)
assert(*p == 13.4);    // The double at memory beginning at address p has value 13.4
*(p + 2) = 29.8;       // Change sizes[3] from 19.4 to 29.8
                       // Note: earlier ++p and + 2 here => sizes[3]
